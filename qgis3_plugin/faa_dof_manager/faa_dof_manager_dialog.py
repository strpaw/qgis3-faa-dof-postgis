# -*- coding: utf-8 -*-
"""
/***************************************************************************
 faa_dof_managerDialog
                                 A QGIS plugin
 Manages data from DOF (Digital Obstacle File) provided by FAA (Federal Aviation Administration)
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-10-13
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Pawe≈Ç Strzelewicz
        email                : @
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from __future__ import annotations

import logging
import os
from pathlib import Path
from typing import Any

from qgis.core import (
    QgsDataSourceUri,
    QgsFeature,
    QgsGeometry,
    QgsPointXY
)
from qgis.PyQt import uic
from qgis.PyQt.QtWidgets import (
    QDialog,
    QMessageBox,
    QWidget
)

from .errors import ObstacleNotFoundError
from .db_values_map import DBValuesMapping
from .db_utils import DBUtils
from .dof_layers import DOFLayers
from .obstacle_data_validator import validate_obstacle
from .load_dof import load_csv


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'faa_dof_manager_dialog_base.ui'))


class FAADOFManagerDialog(QDialog, FORM_CLASS):
    """Plugin dialog window dialog implementation."""

    def __init__(self,
                 db_mapping: DBValuesMapping,
                 db_utils: DBUtils,
                 layers: DOFLayers,
                 parent=None):
        """Constructor."""
        super().__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.db_mapping = db_mapping
        self.db_utils = db_utils
        self.layers = layers
        self.lineEditObstacleIdent.editingFinished.connect(self.load_single_obstacle)
        self.pushButtonInsert.clicked.connect(self.insert_single_obstacle)
        self.mQgsFileWidgetSourceFile.setFilter("*.csv")
        self.pushButtonLoadData.clicked.connect(self.load_dof_data)

    def set_single_mode_drop_down_lists(self) -> None:
        """Fill in drop down list control UI elements with 'human' friendly database value that are used
        to determine primary/foreign keys to update/insert obstacle data.
        """
        self.comboBoxCountryState.addItems(self.db_mapping.oas)
        self.comboBoxHorAcc.addItems(self.db_mapping.hor_acc)
        self.comboBoxVertAcc.addItems(self.db_mapping.vert_acc)
        self.comboBoxObstacleType.addItems(self.db_mapping.obstacle_type.keys())
        self.comboBoxMarking.addItems(self.db_mapping.marking)
        self.comboBoxLighting.addItems(self.db_mapping.lighting.keys())
        self.comboBoxVerificationStatus.addItems(self.db_mapping.verification_status)
        self.comboBoxAction.addItems(["A", "C"])

    def fetch_single_obstacle(self,
                              ident: str,
                              ctry_state_name: str) -> dict[str, Any] | Exception:
        """Fetch data for single obstacle.

        :param ident: ident of the obstacle
        :param ctry_state_name: ctry/state name of the obstacle
        :return: obstacle data from view dof.vw_obstacle
        """
        oas_code = self.db_mapping.oas[ctry_state_name]
        logging.info(f"Fetching data for obstacle: ident {ident}, country/state {ctry_state_name}, oas_code {oas_code}")
        query = (f"select *\n"
                 f"from dof.vw_obstacle\n"
                 f"where oas_code = '{oas_code}'\n"
                 f"      and obst_number = '{ident}';")
        data = self.db_utils.select(query=query)
        logging.info(data)
        if not data:
            logging.info("No obstacle found")
            raise ObstacleNotFoundError

        return data[0]

    def load_single_obstacle(self) -> None:
        """Load single obstacle data into plugin UI from database."""
        ident = self.lineEditObstacleIdent.text()
        ctry_state_name = self.comboBoxCountryState.currentText()

        try:
            data = self.fetch_single_obstacle(ident=ident,
                                              ctry_state_name=ctry_state_name)
        except ObstacleNotFoundError:
            logging.info("No obstacle found")
        else:
            logging.info(f"Fetched data {data}")
            self.lineEditCity.setText(data["city"])
            lat_dms, lon_dms = data["latlon_dms"].split(" ")
            self.lineEditLongitude.setText(lon_dms)
            self.lineEditLatitude.setText(lat_dms)
            self.comboBoxHorAcc.setCurrentText(data["hor_acc"])
            self.lineEditAgl.setText(str(data["agl"]))
            self.lineEditAmsl.setText(str(data["amsl"]))
            self.comboBoxVertAcc.setCurrentText(data["vert_acc"])
            self.comboBoxObstacleType.setCurrentText(data["obst_type_desc"])
            self.comboBoxMarking.setCurrentText(data["marking_desc"])
            self.comboBoxLighting.setCurrentText(data["lighting_desc"])
            self.comboBoxVerificationStatus.setCurrentText(data["verif_status_desc"])
            self.lineEditQuantity.setText(str(data["quantity"]))
            self.lineEditFAAStudyNumber.setText(data["faa_study_number"])
            self.lineEditJulianDate.setText(data["julian_date"])
            self.comboBoxAction.setCurrentText(data["action"])
            self.dateEditValidFrom.setDate(data["valid_from"])
            self.dateEditValidTo.setDate(data["valid_to"])

    def get_single_obstacle_from_gui(self) -> dict[str, Any]:
        """Return single obstacle data from plugin GUI 'single obstacle mode'

        :return: single obstacle data
        """
        return {
            "oas_code": self.db_mapping.oas[self.comboBoxCountryState.currentText()],
            "obst_number": self.lineEditObstacleIdent.text().strip(),
            "verif_status_code": self.db_mapping.verification_status[self.comboBoxVerificationStatus.currentText()],
            "type_id": self.db_mapping.obstacle_type[self.comboBoxObstacleType.currentText()],
            "lighting_code": self.db_mapping.lighting[self.comboBoxLighting.currentText()],
            "marking_code": self.db_mapping.marking[self.comboBoxMarking.currentText()],
            "hor_acc_code": self.db_mapping.hor_acc[self.comboBoxHorAcc.currentText()],
            "vert_acc_code": self.db_mapping.vert_acc[self.comboBoxVertAcc.currentText()],
            "city": self.lineEditCity.text().strip(),
            "quantity": self.lineEditQuantity.text().strip(),
            "agl": self.lineEditAgl.text().strip(),
            "amsl": self.lineEditAmsl.text().strip(),
            "faa_study_number": self.lineEditFAAStudyNumber.text().strip(),
            "action": self.comboBoxAction.currentText(),
            "julian_date": self.lineEditJulianDate.text().strip(),
            "valid_from": self.dateEditValidFrom.date().toString("yyyy-MM-dd"),
            "valid_to": self.dateEditValidTo.date().toString("yyyy-MM-dd"),
            "lon": self.lineEditLongitude.text().strip(),
            "lat": self.lineEditLatitude.text().strip()
        }

    def insert_single_obstacle(self) -> None:
        """Insert obstacle from data in 'single obstacle mode'"""
        data = self.get_single_obstacle_from_gui()
        try:
            data = validate_obstacle(data)
        except ValueError as e:
            QMessageBox.critical(QWidget(), "Message", str(e))
            return

        obstacle_lyr = self.layers.layers["obstacle"]
        feat = QgsFeature(obstacle_lyr.fields())
        feat.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(data["lon"], data["lat"])))

        for field, value in data.items():
            if field in ["lon", "lat"]:
                continue
            feat.setAttribute(field, value)

        # Set insert_user value separately, as this field is not in the plugin dialog graphical user interface
        provider = obstacle_lyr.dataProvider()
        uri = QgsDataSourceUri(provider.dataSourceUri())
        feat.setAttribute("insert_user", uri.username())

        obstacle_lyr.startEditing()
        obstacle_lyr.dataProvider().addFeatures([feat])
        obstacle_lyr.commitChanges(stopEditing=True)

    def load_dof_data(self) -> None:
        """Load DOF data from CSV/DAT file into obstacle table"""
        if not self.mQgsFileWidgetSourceFile.filePath().strip():
            QMessageBox.information(QWidget(), "Message", "Select DOF file to import.")
            return

        dof_path = Path(self.mQgsFileWidgetSourceFile.filePath())
        try:
            load_csv(
                path=dof_path,
                db_utils=self.db_utils,
                obstacle_type_mapping=self.db_mapping.obstacle_type)
        except Exception as e:
            logging.exception("Error while loading data:\n %s", e)
            QMessageBox.critical(QWidget(), "Message", "Error while loading DOF.\nCheck log for details.")
        else:
            QMessageBox.information(QWidget(), "Message", "DOF imported.")
